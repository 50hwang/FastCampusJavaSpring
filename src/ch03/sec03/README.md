ch03 객체 지향 핵심

# ch03.sec03 상속에서 클래스 생성과 형 변환

    어떻게 상속 개념을 통해서, 하위 클래스가 구현하지 않은 상위 클래스의 코드들을 받아다 쓸 수 있는가??

## 하위 클래스가 생성되는 과정

> ch02.sec02의 Customer, VIPCustomer, CustomerTest 클래스 참고 + 이해를 위한 로그 출력 추가

- 하위 클래스를 생성하면, 상위 클래스가 먼저 생성된다.
    - `new VIPCustomer()`를 호출하면, `Customer`가 먼저 호출된다.
    - 테스트 예제 코드 CustomerTest를 실행시켜보면, 하위 객체를 생성했음에도, 상위 클래스의 `Customer() 호출됨`이 출력되었음을 알 수 있다.
 
- 클래스가 상속받은 경우, 하위 클래스의 생성자에서는 반드시 상위 클래스의 생성자를 호출한다.
    - `VIPCustomer() {}` 생성자에 `Customer() {}` 생성자가 없을 경우, 컴파일러가 자동적으로 상위클래스의 기본생성자 `super()`를 호출한다.
    - 자신의 클래스를 참조하는 데 `this`가 있다면, 자신의 상위 클래스를 참조하는 데에는 `super`가 있다.
 
```
	/* Constructors */
	public VIPCustomer() { // 기본 생성자
		
		super();	//<- 안 써주어도 자동 생성되는 상위 클래스
		
		bonusRatio = 0.05;
		customerGrade = "VIP";
		discountRatio = 0.1;
		
		System.out.println("VIPCustomer() 호출됨");
	}
```
 
## super 키워드

> 하위 클래스에서 가지는 상위 클래스에 대한 참조 값

- `super();`는 상위 클래스의 기본 생성자를 호출한다.
- 하위 클래스에서 명시적으로 상위 클래스의 생성자를 호출하지 않으면, 컴파일러에서 자동으로 `super();`가 호출된다.
    - 상위 클래스에서 기본 생성자 없이 파라미터 값을 받는 사용자 정의 생성자만 가질 경우, 하위 클래스에서 생성자 내에 상위 클래스 생성자를 명시해주지 않을 시 오류 발생한다.
       1. 상위 클래스에서 기본 생성자를 명시로 생성해주거나,
       2. 하위 클래스에서 상위 클래스의 사용자 정의 생성자를 명시한다.
    
    - `super`는 생성된 상위 객체의 참조 값을 가지므로, `super`를 이용하여 상위 클래스의 멤버 변수 또는 메소드에 접근할 수 있다.
 
 
- 예제 코드 : Customer2.java, VIPCustomer2.java, CustomerTest2.java
 
 
## 형 변환(업 캐스팅)

> 상위 클래스로 변수 선언, 하위 클래스의 생성자로 인스턴스 생성
>
> `Customer customerLee = new VIPCustomer();`
 
- 상위 클래스 타입의 변수에 하위 클래스 변수가 대입
    - 기본적으로 하위 클래스 타입은 상위 클래스 타입으로 묵시적 형 변환이 일어난다.
    - 왜냐하면, 하위 클래스는 상위 클래스의 타입을 내포하고 있기 때문이다.
 
```
VIPCustomer vCustomer = new VIPCustomer(); 
addCustomer(vCustomer);
int addCustomer(Customer customer) {...}
```
 
- 업캐스팅 된 하위 객체는 상위 객체의 속성(멤버 변수, 메소드)만을 사용할 수 있다.
    - 업캐스팅으로 객체 생성 시, 힙 메모리 상에는 상위 클래스 기반의 하위 객체가 전부 생성되지만, 접근에 한해서만 상위 객체의 속성만을 사용할 수 있음을 의미한다.
 
- 상속 관계에서 모든 하위 클래스는 상위 클래스로 형 변환(업 캐스팅) 된다.
    - 단, 역은 성립하지 않는다!!